# [11-6] From-scratch solver + harvesting

[Back to task list](../tasks.md)

## Description
Implement a fresh Klondike (draw-1) solver from scratch, independent of existing project solvers, using modern best practices. Wire a harvesting runner to find solvable initial tableaux and append them to the human-readable dataset in `src/data/solvable-shuffles.raw.ts`, stopping after 100 new unique entries. Run a small trial first.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
| :-- | :-- | :-- | :-- | :-- | :-- |
| 2025-11-02 13:20:00 | Created | N/A | Proposed | Task created for new solver and harvesting flow. | ai_agent |
| 2025-11-02 13:21:00 | user_approves | Proposed | Agreed | User approved new solver + harvesting plan. | user |
| 2025-11-02 13:22:00 | start_work | Agreed | InProgress | Began implementing solver, dataset format, and harvesting pipeline. | ai_agent |
| 2025-11-02 19:45:00 | submit_for_review | InProgress | Review | New solver, raw dataset, and 100+ harvested shuffles ready for review. | ai_agent |

## Requirements
- Implement a brand new solver (no reuse of existing solver modules) using:
  - Heuristic best-first search with beam pruning and cycle detection.
  - Move ordering to expose hidden cards first; delayed safe foundation moves.
  - State hashing to avoid loops across stock/waste recycles.
- Provide CLI runner with trial and high-capacity modes.
- Append harvested solvable layouts to dataset, avoiding duplicates.
- Stop after 100 unique new solvable layouts in non-trial mode.

## Implementation Plan
1. Create `scripts/klondike-solver-new.js`:
   - Self-contained rules and state model (draw-1), from scratch.
   - Greedy best-first with tunable beam width, node limits, and depth caps.
   - Deterministic hashing of states and dedupe.
2. Create `scripts/harvest-solvable-new.js`:
   - Loop random deals; call solver; on success, extract initial tableau, write to dataset if unique.
   - CLI flags: `--trial`, `--maxSolved`, `--beamWidth`, `--maxNodes`, `--maxDepth`.
3. Run a small `--trial` to validate flow; then execute high-capacity run to gather 100 entries.

## Test Plan
- Trial: `node scripts/harvest-solvable-new.js --trial --maxSolved 3 --beamWidth 500 --maxNodes 200000`.
- Verify dataset grows by up to 3 entries and remains valid (no duplicates; schema intact).
- Spot-check a sampled harvested layout can be played by the app via solvable-only mode.

## Verification
- Trial logs and dataset diff showing new entries.
- Optional: Run a longer session to approach 100 entries once trial is good.

## Files Modified
- `scripts/klondike-solver-new.js` (new)
- `scripts/harvest-solvable-new.js` (update)
- `src/data/solvable-shuffles.raw.ts` (append)
# 11-6 Klondike solver (deckOrder) + difficulty

[Back to task list](../tasks.md)

## Description
Implement a solver for Klondike (draw-1, unlimited recycles) that accepts a `deckOrder` permutation matching the engine’s `createDeck()` order and returns solvability plus a coarse difficulty. Provide a small Node test harness to run random shuffles.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 20:12:00 | Status Change | Proposed | InProgress | Started solver implementation and test harness. | ai-agent |
| 2025-11-01 11:44:00 | Status Change | InProgress | Review | Solver core implemented; CLI harness exercised for DFS and atomic strategies. | ai-agent |

## Requirements
- Input: `deckOrder: number[]` of length 52 mapping indices of `createDeck()`.
- Rules: draw-1, unlimited recycles; treat stock as unordered availability for playability checks.
- Output: `{ solvable: boolean, difficulty?: 'easy'|'medium'|'hard', stats: { nodes: number, depth: number, timeMs: number } }`.
- Performance: bounded search with pruning and transposition table.

## Implementation Plan
- Mirror move legality from engine; reuse ranks/suits and tableau/foundation rules.
- DFS with move ordering and pruning; transposition set keyed by a canonical state string.
- Difficulty buckets by nodes expanded and solution depth.
- Node script `scripts/solve-klondike.js` to print results for random shuffles.

## Verification
- `node scripts/solve-klondike.js --trials=5 --strategy=dfs` — completed; observed 2/5 solves with expected cutoff reporting.
- `node scripts/solve-klondike.js --trials=5 --strategy=atomic` — completed; atomic solver executed with config logging, matching DFS parity.
- `node scripts/solve-klondike.js --trials=5 --strategy=atomic --useNeededRanks=true` — sanity check to ensure optional heuristic flag passes through (see task 1-11).

## Files Modified
- `src/solitaire/klondike_solver.js` (new)
- `scripts/solve-klondike.js` (new)
