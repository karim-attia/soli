# 23-1 Define refactor strategy for Klondike screen

[Back to task list](../tasks.md)

## Description
Establish the architectural blueprint for modularising the Klondike screen so that subsequent tasks can extract UI components, hooks, and utilities without breaking gameplay or animations.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-11-12 13:05:00 | Created | N/A | Proposed | Task created to analyse the Klondike screen refactor scope. | ai_agent |
| 2025-11-12 13:06:00 | Status Change | Proposed | Agreed | User requested the refactor, authorising analysis work. | user |
| 2025-11-12 13:07:00 | Status Change | Agreed | InProgress | Began documenting refactor strategy and follow-up tasks. | ai_agent |
| 2025-11-12 13:18:00 | Status Change | InProgress | Review | Analysis documented; awaiting user confirmation on strategy. | ai_agent |

## Requirements
- Outline a maintainable module structure that satisfies PBI 23 acceptance criteria.
- Identify component boundaries that keep animations, gestures, and persistence flows intact.
- List the follow-up implementation tasks needed to deliver the refactor while keeping scope manageable.

## Implementation Plan
### Current Pain Points
- `app/(tabs)/index.tsx` interleaves reducers, effect chains, animations, gestures, and UI rendering, forcing context switching during edits.
- Shared concepts like card metrics, undo scrub logic, and timer handling lack dedicated modules, leading to repeated inline helpers.
- Animations rely on co-located closure state (`stateRef`, `celebrationBindings`), making it risky to move code without a clear ownership model.

### Target Architecture
- Position `app/(tabs)/index.tsx` as the orchestration shell that loads settings, persists state, and wires animation controllers.
- Create a `src/features/klondike/` namespace with subfolders for `components`, `hooks`, and `logic` to house extracted pieces while avoiding the already crowded `src/solitaire` tree.
- Provide barrel exports (e.g., `src/features/klondike/components/index.ts`) for consumer clarity but keep underlying files focused (`TopRow.tsx`, `TableauSection.tsx`, `UndoScrubber.tsx`, `FeltBackground.tsx`).
- Centralise constants like colours, dimensions, and animation timings inside `src/features/klondike/constants.ts` so components import shared values rather than redeclaring them.

### Component & Animation Strategy
- Keep `useFlightController`, timers, and persistence effects in the entry screen, passing the minimal bindings to child components (card flights, celebration overlays) via typed props.
- Encapsulate card rendering (`CardView`, `WasteFan`, `FoundationPile`, etc.) in a `components/cards` folder where animation bindings are forwarded through props; document expected `SharedValue` contracts above call sites per user instruction.
- Extract the felt pattern and statistics HUD as pure presentational components that receive theming and layout props from the screen.
- Group undo scrubber logic (slider gesture handling, value refs) into a dedicated hook plus component pair to keep stateful logic testable.
- Document animation ownership by commenting in the entry screen when invoking extracted helpers (e.g., `// Handles celebration state -> SharedValue wiring so flights stay in sync`).

### Persistence & Settings Integration
- Create helper hooks (e.g., `useKlondikePersistence`, `useSolvableShuffleSelector`) that wrap existing logic from the monolithic file, keeping side effects near their domains while exposing clear return types.
- Ensure extracted hooks remain tree-shakeable and reusable for future screens (e.g., history recap or tutorials).

### Proposed Follow-up Tasks (to be created after analysis approval)
1. **23-2 Extract layout scaffolding** – Move felt background, statistics HUD, and undo scrubber into dedicated components, wiring props from the screen.
2. **23-3 Modularise card and pile components** – Relocate `CardView`, `WasteFan`, `FoundationPile`, tableau columns, and related constants into `components/cards`, ensuring animation bindings are passed explicitly.
3. **23-4 Isolate orchestration hooks** – Create hooks for timers, persistence, solvable shuffle selection, and celebration lifecycle, keeping `index.tsx` focused on wiring.
4. **23-5 Integrate new structure and update comments** – Recompose the screen with the extracted modules, add descriptive comments above moved function calls, and verify behaviour.
5. **23-6 Regression verification task** – Run targeted playthroughs and automated checks (lint, typecheck) to ensure no regressions after refactor.

## Test Plan
- No automated tests are required for this analysis task; peer review of the documented plan suffices.
- Verify the proposed structure aligns with existing module conventions (`src/features/*`, `src/components/*`).

## Verification
- Confirm the plan addresses PBI acceptance criteria and clearly assigns future work to discrete tasks.
- Review component boundaries with the user to ensure expectations around animations and UI fidelity are captured.

## Files Modified
- `docs/delivery/backlog.md`
- `docs/delivery/23/prd.md`
- `docs/delivery/23/tasks.md`
- `docs/delivery/23/23-1.md`
