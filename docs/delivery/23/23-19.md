# 23-19 Plan container/view split

[Back to task list](../tasks.md)

## Objective
Document how the new `useKlondikeGame` container hook, the `KlondikeGameView` presentational component, and the existing `tab` entry point should divide responsibilities before implementing the split.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-11-12 20:28:00 | Created | N/A | Proposed | Task captured to plan the container/view split. | ai_agent |
| 2025-11-12 20:29:00 | Status Change | Proposed | InProgress | Drafting responsibilities for hook, view, and index. | ai_agent |
| 2025-11-12 20:34:00 | Status Change | InProgress | Review | Analysis completed per instructions. | ai_agent |

## Current Pain Points
- `app/(tabs)/index.tsx` combines reducer orchestration, persistence, demo logic, and UI composition, making it hard to reason about.
- We already have reusable hooks (timer, persistence, celebrations), but the screen still wires them together directly, limiting reuse (e.g., on web).
- Navigation-specific concerns (drawer buttons) are mixed with general gameplay UI.

## Proposed Structure

### 1. `useKlondikeGame` (new hook under `src/features/klondike/hooks/`)
- **Responsibilities**
  - Own the reducer (`useReducer(klondikeReducer, ...)`) and all supporting refs (`stateRef`, `previousHasWonRef`, etc.).
  - Host every `useEffect`/`useMemo` block that manipulates game state (persistence, demo links, celebrations, undo scrubber wiring, auto-queue runner).
  - Expose:
    - `developerModeEnabled`
    - Navigation-safe callbacks: `requestNewGame`, `handleLaunchDemoGame`
    - Derived view-model (`viewProps`) that the view component can render.
- **Inputs**
  - None (hook derives everything from internal state + settings/context).
- **Outputs**
  - `developerModeEnabled` (for nav icons)
  - `requestNewGame` (memoized)
  - `handleLaunchDemoGame`
  - `viewProps: KlondikeGameViewProps`

### 2. `KlondikeGameView` (new component under `src/features/klondike/components/`)
- **Responsibilities**
  - Receive declarative `viewProps` and render the UI (header stats, board layout, undo scrubber, celebration blocker).
  - Never call reducers or side-effect hooks; only invoke callbacks passed via props.
  - Import purely visual dependencies (`FeltBackground`, `StatisticsHud`, `TopRow`, `TableauSection`, `UndoScrubber`, etc.).
- **Required Props (`KlondikeGameViewProps`)**
  - `feltBackground`
  - `headerPadding` (top/left/right after safe-area adjustments)
  - `statisticsRows`
  - Board wiring: `onBoardLayout`, `topRowProps`, `tableauProps`
  - Celebration info: `celebrationState`, `celebrationLabel`, `celebrationBindings`, `onCelebrationAbort`
  - Undo scrubber props (mirroring the existing component)

### 3. `app/(tabs)/index.tsx`
- **Responsibilities**
  - Hook up navigation (drawer button, header actions).
  - Use `useDrawerOpener`, `useNavigation`, and `useLayoutEffect` only.
  - Consume `useKlondikeGame`, pass `viewProps` to `<KlondikeGameView />`, and otherwise stay unaware of game internals.

## Placement of Supporting Logic

| Concern | Location | Notes |
| --- | --- | --- |
| Game reducer, drop hints, history recording | `useKlondikeGame` (uses existing helpers from `klondike.ts`/history) | `klondike.ts` stays purely game-logic; the hook coordinates it. |
| Card metrics computation | `useKlondikeGame` (imports helper) | Already in `src/features/klondike/utils/cardMetrics.ts`. |
| Statistics rows + elapsed formatting | `buildStatisticsRowsForState` (UI helper) | Hook invokes it; view simply renders given rows. |
| Undo scrubber / gestures | `useUndoScrubber` (already abstracted) | Hook collects results and forwards via `viewProps`. |
| Auto queue runner | `useAutoQueueRunner` | Hook owns invocation (previous `useEffect`). |
| Celebration controller | `useCelebrationController` | Hook uses it; view just renders overlay. |
| Selection helpers (`collectSelectionCardIds`) | Remain near hook (since flight controller still needs them) | Hook documents their purpose post manual-selection removal. |

## Statistics Question
- **Where should elapsed time be computed?**  
  Keep it inside the statistics helper (`buildStatisticsRowsForState`) so neither the hook nor the view needs to juggle `computeElapsedWithReference`.
- **UI vs logic boundary**  
  Anything that mutates state or depends on contexts (history, settings, persistence) stays in `useKlondikeGame`. `KlondikeGameView` should only render values provided via props.

## klondike.ts Scope
- Remains the home for pure game logic: reducer, auto-complete planning, drop hints, etc.
- No UI/persistence hooks should move into `klondike.ts`.
- The new architecture simply consumes its exports via `useKlondikeGame`.

## Next Steps
1. Implement `useKlondikeGame` by moving the current TabOneScreen logic into the hook.
2. Create `KlondikeGameView` with the existing JSX layout (minus stateful hooks).
3. Slim `app/(tabs)/index.tsx` down to navigation + rendering the view.
4. Ensure all functions in the hook retain the one-line description style.


