# [13-2] Implement AsyncStorage-backed game persistence

[Back to task list](../tasks.md)

## Description
Integrate `@react-native-async-storage/async-storage` so the Klondike game saves its state after each move and restores it automatically on launch, with defensive handling for corrupted payloads.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
| :-- | :-- | :-- | :-- | :-- | :-- |
| 2025-11-01 12:23:00 | Created | N/A | Proposed | Logged need to persist and restore game state via AsyncStorage. | ai_agent |
| 2025-11-01 12:24:00 | user_approves | Proposed | Agreed | User approved implementing AsyncStorage persistence. | user |
| 2025-11-01 12:29:00 | start_work | Agreed | InProgress | Began wiring AsyncStorage saves and loads for Klondike state. | ai_agent |
| 2025-11-01 13:20:00 | submit_for_review | InProgress | Review | AsyncStorage persistence committed with hydration, saves, and tests ready for review. | ai_agent |
| 2025-11-02 12:10:00 | approve | Review | Done | User approved AsyncStorage-backed game persistence implementation. | user |

## Requirements
- Add `@react-native-async-storage/async-storage` to the project using the official installation steps (cached 2025-11-01).
- Serialize and store the full Klondike game state, including deck order, tableau columns, waste/stock, foundations, timers, and undo history.
- Restore the saved state on initial mount, falling back to a fresh game when no data exists or parsing fails.
- Clear storage when a new game starts or the user resets, ensuring stale snapshots are removed.
- Surface a toast if saved data is unreadable and must be discarded.

## Implementation Plan
1. Add AsyncStorage dependency (`npx expo install @react-native-async-storage/async-storage`) and document usage per official install/usage guides.
2. Create `src/storage/gamePersistence.ts` to centralize serialization/deserialization, schema versioning, and storage key constants.
3. Extend the Klondike reducer/controller to emit persistence events after mutating actions (draw, move, undo, recycle, auto-complete).
4. On component mount (`app/(tabs)/index.tsx`), attempt to load persisted state before initializing a new game, applying migrations if the version differs.
5. Handle failures by clearing storage, logging the error, and showing a toast explaining that the game was reset.
6. Clear persistence when a player chooses “New Game” or wins and starts over.
7. Cover helpers with targeted unit tests and update existing tests to mock AsyncStorage as needed.

## Test Plan
- Unit: Add tests for `gamePersistence.ts` to ensure serialize/deserialize round-trips and corrupted payloads clear storage.
- Unit: Mock AsyncStorage in reducer tests to verify save calls occur after each action.
- Manual: Play several moves, background/kill the app, relaunch, and confirm the board resumes from the saved state.
- Manual: Corrupt storage via dev menu or by writing invalid JSON, reload, and confirm storage clears with toast feedback.
- Manual: Start a new game and verify previous persisted state is cleared.
- `yarn test --watch=false` and `yarn tsc --noEmit`.

## Verification
- Confirm persistence triggers on all reducer actions that mutate cards.
- Validate manual smoke tests on iOS simulator and web build.
- Ensure AsyncStorage dependency links correctly by running the app via Expo Go.
- `yarn tsc --noEmit`
- `yarn test --watchAll=false`

## Files Modified
- `package.json`
- `yarn.lock`
- `app/(tabs)/index.tsx`
- `src/storage/gamePersistence.ts`
- `src/solitaire/klondike.ts`
- `test/unit/storage/gamePersistence.test.ts`
- `docs/delivery/13/13-2-async-storage-guide.md`

