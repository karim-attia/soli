# 20-6 Fix iOS scrubber gesture premature cancellation

[Back to task list](./tasks.md)

## Description
Difficulty: Medium. On iOS, the undo scrubber frequently closes even though the user is still swiping. This does not occur on Android. The issue may be triggered when:
- The user swipes over the scrubber overlay area
- The finger passes over/through the original touch origin point
- Vertical finger movement exceeds the `activeOffsetY` threshold

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-12-11 10:00:00 | Created | N/A | Proposed | Task file created for iOS gesture investigation. | ai_agent |
| 2025-12-11 10:01:00 | Status Change | Proposed | InProgress | Beginning investigation with hypotheses and instrumentation. | ai_agent |
| 2025-12-12 11:29:37 | Status Change | InProgress | Review | Implemented fix; Appium suite passes (20/20) with mid-scrub refresh required. | ai_agent |
| 2025-12-13 11:10:51 | Status Change | Review | InProgress | Regression fix: Undo tap stopped working; restore stable visuals + verify Appium. | ai_agent |
| 2025-12-13 11:11:51 | Status Change | InProgress | Review | Undo tap works again and Appium scrub suite passes (20/20). | ai_agent |
| 2025-12-13 11:48:55 | Cleanup | Review | Review | Removed experimental global scrub flag + deleted redundant docs; Appium passes (20/20). | ai_agent |
| 2025-12-13 18:28:36 | Cleanup | Review | Review | Removed in-app debug logging for release readiness. | ai_agent |
| 2025-12-14 20:08:17 | significant_update | Review | InProgress | Replace hardcoded 100px bottom margin with safe-area driven bottom padding for iOS/Android gesture areas. | ai_agent |
| 2025-12-14 20:10:29 | Status Change | InProgress | Review | Use safe-area insets (bottom) instead of hardcoded margin for undo scrubber spacing. | ai_agent |

## Requirements
- Investigate why the pan gesture ends prematurely on iOS but not Android
- Document root cause with evidence from runtime logs
- Fix the issue without breaking Android behavior or introducing regressions

## Hypotheses

### Hypothesis A: `activeOffsetY` threshold too restrictive
The gesture is configured with `.activeOffsetY([-20, 20])` which means if the user's finger moves more than 20 points vertically, the gesture may fail to activate or be cancelled. iOS touch events may report more vertical jitter than Android.

### Hypothesis B: Gesture fails when finger re-crosses origin point
When the user swipes left then right (or vice versa), passing through the original touch point, iOS may interpret this as a gesture end/restart condition differently than Android.

### Hypothesis C: `onFinalize` called prematurely by iOS gesture system
The `onFinalize` callback is intended for cleanup but may be invoked by iOS's gesture recognizer in edge cases (e.g., system interrupts, gesture conflicts) before the actual touch ends.

### Hypothesis D: Gesture conflict with other recognizers
The button's `onPress` handler or the slider overlay's touch handling may compete with the pan gesture on iOS, causing the pan to be cancelled when the finger enters certain regions.

### Hypothesis E: Touch slop or distance threshold differences
iOS may have different default touch slop values that interact with `.minDistance(2)` differently, potentially causing early gesture termination.

### Hypothesis F: Tamagui Button internal gesture conflict
The Tamagui Button component's `onPress` handler creates a competing native gesture recognizer. On iOS, when both the Button's tap handler and the Pan gesture are active, they compete for touch ownership. Random cancellations occur when iOS decides to give control to the Button's native tap recognizer mid-pan.

### Hypothesis G: Tamagui Button not forwarding gesture handler refs
`GestureDetector` requires its child to properly forward refs to a native view. The Tamagui Button may not properly implement this on iOS, causing the gesture system to attach to the wrong view or not attach at all. This results in 100% cancellation rate for pan gestures while tap gestures (which have different timing) occasionally succeed.

### Hypothesis H: Tamagui Button internal touch state management
Even without `onPress`, Tamagui Button has internal touch handling for press states (pressed/hover animations, accessibility). This internal responder system may be competing with gesture-handler on iOS, causing cancellations even when wrapped in Animated.View.

### Hypothesis I: Parent gesture handler stealing touches
Expo Router's Drawer navigator, ToastProvider with `swipeDirection="horizontal"`, or other parent components may have gesture handlers that are winning gesture arbitration on iOS, cancelling our pan gesture mid-swipe.

### Hypothesis J: Drawer gesture handlers still active despite swipeEnabled:false
Even with `swipeEnabled: false`, the Drawer component may register gesture handlers that interfere with child gestures on iOS. Need to also set `gestureEnabled: false` and use `.cancelsTouchesInView(false)` on the pan gesture.

### Hypothesis K: Gesture recreation during scrubbing due to state changes
**ROOT CAUSE IDENTIFIED**: When scrubbing dispatches SCRUB_TO_INDEX actions, `state.history.length` changes. This causes `shouldShowUndo` to be recalculated, which is in the useMemo dependencies for the gesture. The gesture object is recreated mid-swipe, **cancelling the active gesture on iOS**.

## Implementation Plan

1. **Instrument gesture callbacks** - Add debug logging to `onStart`, `onUpdate`, `onEnd`, and `onFinalize` to capture exact event sequences
2. **Log gesture state details** - Track `event.state`, `event.absoluteX`, `event.absoluteY`, `event.translationX`, `event.translationY`
3. **Log when `isScrubbing` changes** - Track state transitions to correlate with gesture events
4. **Compare iOS vs Android logs** - Identify which callback sequence differs
5. **Apply targeted fix based on evidence**

## Test Plan
- **Note (2025-12-13)**: The in-app debug logging used for Appium assertions (`debug.log`, `GESTURE_SUMMARY`, etc.) was removed for release readiness. Repeatable automated assertions would require reintroducing that instrumentation or adding dedicated test hooks.
- **Manual (iOS simulator + physical)**:
  - Scrub left/right continuously while board updates are happening (must not close)
  - Verify board previews update regularly during the scrub (no “frozen board”)
- **Automated (Appium, no screenshots)**:
  - Use `@docs/delivery/appium-testing-guide.md` to run pointer-action scrubs
  - Assert from `@.cursor/debug.log`:
    - `GESTURE_SUMMARY.gestureState === 5` (no cancel)
    - `GESTURE_SUMMARY.noRefreshFail === false` (at least 1 mid-scrub refresh happened)

## Files Modified
- `src/features/klondike/hooks/useUndoScrubber.ts` (instrumentation + fix)
- `src/features/klondike/hooks/useKlondikeGame.ts` (propagate `scrubbingActive`)
- `src/features/klondike/components/UndoScrubber.tsx` (debug hooks)
- `src/features/klondike/components/cards/CardView.tsx` (disable layout tracking during scrubbing)
- `src/features/klondike/components/cards/TableauSection.tsx` (pass `scrubbingActive` → `layoutTrackingEnabled`)
- `src/features/klondike/components/cards/TopRow.tsx` (pass `scrubbingActive` → `layoutTrackingEnabled`)
- `src/features/klondike/components/cards/FoundationPile.tsx` (pass `layoutTrackingEnabled`)
- `src/features/klondike/components/cards/WasteFan.tsx` (pass `layoutTrackingEnabled`)
- `src/features/klondike/components/cards/StockStack.tsx` (pass `layoutTrackingEnabled`)
- `components/Provider.tsx` (wrap app in `GestureHandlerRootView`)
- This task file (findings documentation)

## Findings

### Log Analysis (2025-12-11)

**Hypothesis Evaluation:**

| Hypothesis | Status | Evidence |
|------------|--------|----------|
| A: `activeOffsetY` too restrictive | REJECTED | Gestures continue even with `translationY` values exceeding -150 points. The threshold only affects activation, not ongoing tracking. |
| B: Crossing origin point | REJECTED | Gestures continue working when crossing the origin point without issue. |
| C: `onFinalize` called prematurely | **CONFIRMED** | Multiple instances of `GESTURE_FINALIZE` with `state: 3` (CANCELLED) and `success: false` while user is mid-gesture. |
| D: Gesture conflict | INCONCLUSIVE | No `SCRUBBING_RESET_BY_EFFECT` logs observed. |
| E: Touch slop differences | REJECTED | `minDistance(2)` works correctly - gestures activate properly. |

**Root Cause Identified:**

The pan gesture handler's default behavior on iOS is to cancel the gesture when the finger moves outside the originating view's bounds. The Undo button has `width="50%"` (~195 points on a ~390pt screen). When the user's finger crosses past the button's edges (e.g., `absoluteX > ~300`), iOS cancels the pan gesture with `state: 3` (CANCELLED).

Evidence from logs:
- Successful gesture completions: `gestureState: 5` (END), `success: true`
- Premature cancellations: `gestureState: 3` (CANCELLED), `success: false` - all occurred when `absoluteX` exceeded button bounds

**Initial Fix Attempted (Failed):**

Added `.shouldCancelWhenOutside(false)` to the pan gesture configuration - this did NOT fix the issue because cancellations occurred even within button bounds.

**Second Fix Applied (Hypothesis F):**

The real issue was the Tamagui Button's `onPress` handler competing with the Pan gesture. On iOS, these gesture recognizers conflict, causing random cancellations.

Solution: Used `Gesture.Exclusive(panGesture, tapGesture)` to compose:
- A `Gesture.Tap()` for undo (replaces Button's onPress)
- A `Gesture.Pan()` for scrubbing (with `activeOffsetX`, `failOffsetY` for better activation)

The Pan takes priority when horizontal movement is detected; otherwise it falls back to Tap for single undo. This eliminates the native Button gesture conflict.

**Third Fix Applied (Hypothesis G):**

The `Gesture.Exclusive()` composition didn't help - pan gestures still showed 100% cancellation rate with `state: 3`. The issue was that `GestureDetector` was directly wrapping the Tamagui Button, which doesn't properly forward gesture handler refs on iOS.

Solution: Wrapped the Button in an `Animated.View` (a proper native view) and applied the `GestureDetector` to that wrapper. Native views properly implement ref forwarding for gesture handlers.

**Fourth Fix Applied (Hypothesis H):**

The Animated.View wrapper didn't help - 100% cancellation rate persisted. The Tamagui Button still had internal touch handling competing with gestures.

Solution: Replaced the Tamagui Button entirely with a plain `Animated.View` styled to look like a button, using only native React Native components (`View`, `Text`, icon). This eliminates ALL Tamagui touch handling.

**Fifth Fix Applied (Hypothesis I):**

Plain Animated.View still showed 100% cancellation rate - proves the issue is NOT at component level but at parent hierarchy level. Parent gesture handlers (Drawer, ToastProvider) are winning gesture arbitration.

Solution: Wrap the GestureDetector in its own `GestureHandlerRootView` on iOS only. This creates an isolated gesture handling context that prevents parent gesture handlers from stealing our touches.

**Sixth Fix Applied (Hypothesis J):**

Even with local `GestureHandlerRootView`, gestures still cancelled. The issue is at a deeper level - the Drawer's internal gesture handlers still register even with `swipeEnabled: false`.

Solutions applied:
1. Added `gestureEnabled: false` to Drawer screenOptions to completely disable drawer gestures
2. Added `.cancelsTouchesInView(false)` to pan gesture to prevent iOS touch cancellation
3. Added `.runOnJS(true)` to run gesture callbacks on JS thread for better iOS compatibility

**Seventh Fix Applied (Hypothesis K - ROOT CAUSE):**

Web research and code analysis revealed the true root cause: The gesture's useMemo was recreating the gesture object whenever `shouldShowUndo` or `boardLocked` changed. During scrubbing, dispatching SCRUB_TO_INDEX changes `state.history.length`, which changes `shouldShowUndo`, triggering gesture recreation and cancellation.

Solutions applied:
1. Changed gesture `.enabled()` to always be `true` - check enablement in handlers instead
2. Used `gestureEnabledRef` and `canUndoRef` refs to track enabled state without causing gesture recreation
3. Minimized useMemo dependencies to only the stable callback functions
4. Gestures are now stable across state changes and won't be cancelled mid-swipe

**Eighth Fix Applied (Callback Recreation):**

Logs showed `GESTURE_MEMO_REBUILD` happening rapidly during scrubbing. Even though gesture useMemo had minimal deps, the callbacks themselves were being recreated because they had dependencies on `state.history.length`, `shouldShowUndo`, `timelineRange` etc.

Solutions applied:
1. Created refs for ALL state values: `stateRef`, `timelineRangeRef`, `shouldShowUndoRef`, `boardLockedRef`
2. Updated `handleScrubGestureStart` and `handleScrubGestureUpdate` to read from refs instead of closure values
3. Removed all state-based dependencies from useCallback - only stable refs and callbacks remain
4. Added safe-area driven bottom padding to keep scrubber above the iOS home indicator / Android navigation gesture area

**Ninth Fix Applied (Manual Activation - Hypothesis L):**

Logs confirmed callbacks are now stable (no GESTURE_MEMO_REBUILD during scrubbing), but gesture still being cancelled (state: 3). This means iOS native gesture arbitration is cancelling our gesture externally.

Solutions applied:
1. Added `.manualActivation(true)` on iOS to take explicit control of gesture activation
2. Added `.onTouchesDown()` to reset activation state on new touch
3. Added `.onTouchesMove()` with stateManager.activate() to manually activate after detecting touch
4. Relaxed `.failOffsetY([-30, 30])` to be more lenient
5. On iOS: minDistance=0 and activeOffsetX=[-1000,1000] since we control activation manually

**Tenth Fix Applied (Native Worklets + blocksExternalGesture - Hypothesis N):**

Research showed the key to native gesture handling:
1. **Worklets** - Run gesture callbacks on native UI thread (`'worklet'` directive), not JS thread
2. **`blocksExternalGesture()`** - Prevents external gestures from interrupting once active
3. **`runOnJS()`** - Call JS functions from worklets when needed

Solutions applied:
1. Removed `.runOnJS(true)` - now using native worklets instead
2. Added `'worklet'` directive to all gesture callbacks (onStart, onUpdate, onEnd, onFinalize)
3. Added `.blocksExternalGesture()` to prevent external gesture interruption
4. Use `runOnJS()` from `react-native-reanimated` to call JS handlers from worklets
5. Removed manual activation approach - using native gesture recognition instead

**Eleventh Fix Applied (Remove Gesture.Exclusive - Hypothesis P):**

Detailed pattern analysis showed NO correlation between cancellation and any gesture behavior (edges, origin crossing, direction changes, distance, duration). This is a BLANKET cancellation by iOS - not pattern-based.

Hypothesis: The `Gesture.Exclusive(pan, tap)` composition may be causing iOS arbitration issues.

Solutions applied:
1. On iOS: Use pan gesture ONLY (no tap gesture composition)
2. Detect taps in pan's onEnd when translation < 15px
3. Android continues using Gesture.Exclusive(pan, tap)
4. This isolates whether the Exclusive composition is causing iOS cancellations

**Twelfth Fix Applied (handleUndo ref - Hypothesis Q - TRUE ROOT CAUSE):**

Logs revealed `GESTURE_MEMO_REBUILD` events happening DURING active scrubbing (e.g., between update events). Analysis traced the cause:

1. `handleTapEnd` depends on `handleUndo` (a prop)
2. `handleUndo` changes when game state updates during scrubbing
3. This causes `handleTapEnd` to be recreated
4. Which triggers gesture useMemo rebuild
5. Which cancels the active gesture on iOS

Solution: Added `handleUndoRef` ref and removed all dependencies from `handleTapEnd`:
```javascript
const handleUndoRef = useRef(handleUndo)
handleUndoRef.current = handleUndo

const handleTapEnd = useCallback(() => {
  if (canUndoRef.current) {
    handleUndoRef.current()
  }
}, []) // NO dependencies - completely stable
```

**Thirteenth Fix Applied (Remove nested GestureHandlerRootView - Hypothesis R):**

Logs confirmed gesture is now stable (no GESTURE_MEMO_REBUILD during scrubbing), but gestures still cancelled externally by iOS.

Analysis: The UndoScrubber component had a **nested GestureHandlerRootView** on iOS. Having nested GestureHandlerRootViews can cause gesture arbitration conflicts where the inner view's gestures get cancelled by the outer root.

Solutions applied:
1. Removed nested `GestureHandlerRootView` wrapper on iOS
2. Added `collapsable={false}` to prevent React Native from optimizing away the native view
3. Unified iOS/Android rendering to use same simple structure

**Fourteenth Fix Applied (Fix false tap detection at origin - Hypothesis S):**

Logs revealed TAP_GESTURE_END being triggered when crossing the origin! The tap detection was checking `translationX < 15`, but when crossing the origin point, translationX is naturally small (near 0) even during active scrubbing.

Root cause: When the user scrubs left, then scrubs right back through the origin, at that exact crossing point:
- `translationX` goes from negative → 0 → positive
- The gesture gets cancelled by iOS (state: 3)
- The `onEnd` handler sees `translationX < 15` and incorrectly treats it as a tap
- This triggers `handleTapEnd()` which performs an actual undo operation!

Fix: Only treat as tap if `event.state === 5` (successful END), not if cancelled (state 3):
```javascript
const isSuccessfulEnd = event.state === 5
const isMinimalMovement = Math.abs(event.translationX) < 15
const isTap = isSuccessfulEnd && isMinimalMovement
```

**Fifteenth Fix Applied (simultaneousWithExternalGesture - Hypothesis T):**

Logs showed gestures now run much longer (up to 2400ms, 111 updates) and successfully cross the origin. But iOS still eventually cancels them. 

Web research indicated that using `simultaneousWithExternalGesture()` allows gestures to run alongside external gestures (like system gestures) rather than competing with them. Changed from `blocksExternalGesture()` to `simultaneousWithExternalGesture()` - this tells iOS to run our gesture in parallel with any system gestures rather than trying to block them.

**Sixteenth Fix Applied (Adjust gesture constraints - Hypothesis U):**

Logs showed gestures now running 5+ seconds (5280ms, 212 updates) but still eventually cancelled. Analysis revealed many cancellations occur when translationX is near 0 (user returned close to start position).

Changes:
1. Removed `activeOffsetX([-10, 10])` - this constraint may cause iOS to re-evaluate the gesture when translation returns to near 0
2. Increased `failOffsetY` from [-30, 30] to [-100, 100] - more tolerant of natural vertical finger drift during horizontal scrubbing
3. Added Y translation data to finalize logging for better diagnostics

**Seventeenth Fix Applied (Manual activation control - Hypothesis V):**

Logs showed 3/16 gestures now complete successfully (~19% success rate) - progress! But still random cancellations, even for very long gestures (5387ms with 151 updates).

Using `.manualActivation(true)` on iOS gives us explicit control over gesture lifecycle:
- `onTouchesDown`: Log touch start (don't activate yet to allow tap detection)
- `onTouchesMove`: Explicitly activate the gesture when movement detected
- `onTouchesUp`: Explicitly end the gesture when all fingers lifted

This prevents iOS from arbitrarily cancelling our gesture - we control when it activates and ends.

**Eighteenth Fix Applied (Add onTouchesCancelled logging - Hypothesis W):**

Logs showed `MANUAL_TOUCHES_DOWN` and `MANUAL_TOUCHES_MOVE` firing, but **NO** `MANUAL_TOUCHES_UP`! This means iOS is cancelling the touches at the native level before our handler runs.

Added `onTouchesCancelled` callback to confirm this hypothesis and understand exactly when/why iOS is cancelling the touches. This callback fires when the system forcefully cancels touch events.

**Nineteenth Fix Applied (External gesture requirements - Hypothesis X):**

**ROOT CAUSE CONFIRMED**: `MANUAL_TOUCHES_CANCELLED` fires every time with `state: 4` (ACTIVE) and `touchCount: 1` (finger still on screen!). iOS is forcefully cancelling our touches while the user is still swiping.

The Y position (~707) suggests the iOS home indicator gesture area at the bottom of the screen is claiming touch priority.

New approach:
1. Removed manual activation (wasn't preventing cancellation)
2. Added `.requireExternalGestureToFail()` - tells iOS our gesture should only fail if external gestures explicitly claim the touch
3. Added `.hitSlop({ bottom: 50, top: 50, left: 20, right: 20 })` - extends gesture recognition area
4. Keep `.simultaneousWithExternalGesture()` for parallel recognition

**Twentieth Fix Applied (Increase bottom margin - Hypothesis Y):**

Screenshot analysis confirmed the Undo button was positioned directly above the iOS home indicator at ~Y:707, which is inside the iOS protected gesture zone where system gestures have priority.

Tested with 200px margin - gesture still cancelled. This proved the home indicator zone was NOT the cause.

---

## ROOT CAUSE FOUND (Hypothesis Z) - Using Appium for automated testing

**Testing with Appium XCUITest** (native iOS touch automation) revealed the true root cause:

1. **Experiment**: Disabled `dispatch({ type: 'SCRUB_TO_INDEX' })` during scrubbing
2. **Result**: Gesture completed successfully for full 5+ seconds (5116ms, 308 updates)
3. **Conclusion**: **State updates during scrubbing cause gesture cancellation on iOS**

The React state updates from dispatching `SCRUB_TO_INDEX` during the gesture were triggering re-renders that somehow caused iOS's gesture handler to cancel the pan gesture.

**INITIAL FIX IMPLEMENTED:**
```typescript
// In scheduleScrubDispatch:
if (Platform.OS === 'ios' && isScrubbingRef.current) {
  // Skip dispatch during scrubbing on iOS - will dispatch final position when gesture ends
  return
}
dispatch({ type: 'SCRUB_TO_INDEX', index: pending })
```

This defers state updates until the gesture completes. During scrubbing, only the visual slider position updates. When the user lifts their finger, the final position is dispatched to update the game state.

---

## IMPROVED SOLUTION - Mid-scrub board updates with gesture stability

**Problem**: The initial fix worked but didn't show board updates during scrubbing, making it hard for users to find the exact undo point.

**Experimentation with Appium** (automated iOS testing) revealed:
- `startTransition` alone: ~5 dispatches → gesture cancelled at ~2s
- 150ms throttle: ~4 dispatches → gesture cancelled
- 200ms throttle: 1 dispatch → gesture succeeded
- 300ms throttle: 0 dispatches → gesture succeeded
- `minDelta=2` (skip small changes): 7 dispatches → cancelled
- `minDelta=5`: 2 dispatches → cancelled at 3.1s
- `minDelta=10`: 2 dispatches → cancelled at 3.6s

**KEY INSIGHT**: Each dispatch adds cumulative "debt" that eventually causes gesture cancellation. The sweet spot is **exactly 1 mid-scrub dispatch**.

**FINAL IMPLEMENTATION:**
```typescript
// In scheduleScrubDispatch:
if (Platform.OS === 'ios' && isScrubbingRef.current) {
  const scrubElapsed = gestureDebug ? Date.now() - gestureDebug.startTime : 0
  const startIdx = gestureDebug?.startIndex ?? prevIndex
  const hasDispatchedMidScrub = prevIndex !== startIdx
  // Only dispatch once after 2s of scrubbing (if we haven't dispatched yet and delta >= 5)
  if (hasDispatchedMidScrub || scrubElapsed < 2000 || Math.abs(delta) < 5) {
    return
  }
}
// Always use startTransition for non-urgent updates
startTransition(() => {
  dispatch({ type: 'SCRUB_TO_INDEX', index: pending })
})
```

**Benefits:**
1. **Board updates during scrub**: User sees the board update once at ~2s, giving them a preview
2. **Gesture stability**: Only 1 mid-scrub dispatch keeps gesture alive for full duration
3. **Final update**: Board updates to exact position when gesture ends
4. **Works with React concurrent features**: `startTransition` marks updates as non-urgent

**Test Results (verified with Appium):**
- 3/3 stability tests passed (4.6s, 4.0s, 5.1s gestures)
- Mid-scrub dispatch at ~2s when delta >= 5
- Final dispatch when gesture ends
- All gestures completed successfully with `gestureState: 5`

---

## UPDATED ROOT CAUSE + FINAL FIX (2025-12-12)

### Architecture diagram: what refreshes, and why it cancelled

```text
Finger down + pan active
  │
  ├─ onUpdate → compute target index (JS)
  │        │
  │        └─ dispatch SCRUB_TO_INDEX (JS)  ← we need this for live previews
  │                 │
  │                 ├─ React render/commit (RN)
  │                 ├─ Board subtree updates (cards move piles)
  │                 └─ CardView onLayout storm → measure() + shared-value writes
  │                          │
  │                          └─ iOS cancels active pan (gestureState: 3)
  │
  └─ overlay hides (old behavior) even though finger still down
```

### Reproducible evidence (Appium + debug.log)

**Key logging added**:
- `SCRUB_DISPATCH_SCHEDULE` / `SCRUB_DISPATCH_EXEC`: when we dispatch during scrub
- `STATE_REFRESH`: when the state change commits (board actually “refreshes”)
- `GESTURE_SUMMARY`: includes `noRefreshFail`, `stateRefreshCount`, and timing (`msSinceLastStateRefresh`)

**Baseline repro (before final fix)**:
- The scrub gesture reliably cancelled shortly after the **first** `STATE_REFRESH` while finger remained down.
- This met the “refresh happened” requirement but failed stability.

### Actual root cause (why “any dispatch” looked cursed)

The issue was **not** “Redux dispatch inherently cancels iOS pan”.

It was the **native churn caused by card layout tracking** during rapid `SCRUB_TO_INDEX` updates:

- Many card components update position quickly while scrubbing.
- Each `CardView` was running **`onLayout → measure()`** (Reanimated) to maintain flight snapshot state.
- During scrubbing, this becomes a **layout/measure storm** on iOS.
- That native work correlates with the iOS pan cancelling.

### Final implementation (works with regular mid-scrub refreshes)

**Fix**: disable card layout tracking while scrubbing so scrubbing commits don’t trigger `measure()` storms.

- Added `layoutTrackingEnabled?: boolean` to `CardView`
- During scrubbing (`scrubbingActive === true`), pass `layoutTrackingEnabled={false}` from:
  - `TopRow` → `FoundationPile` / `WasteFan` / `StockStack`
  - `TableauSection` → `CardView`

### Results

With layout tracking disabled during scrubbing:
- Scrubbing can dispatch **many** times mid-gesture
- Board previews update regularly
- **No iOS cancels** in the reproducible Appium suite

**Automated verification**:
- Appium suite: **20/20 passed**
  - `gestureState === 5`
  - `noRefreshFail === false`
  - `stateRefreshCount` typically 30+ per scrub (regular updates)

### UI constraint discovered (2025-12-13)

Attempting to visually place the **slider overlay above the Undo button** (higher `zIndex`, so the button looks “behind” it) **reintroduced iOS cancellations**.

Reason: the slider overlay updates frequently during scrubbing (thumb/value updates). When that updating view sits *above* the gesture target under the finger, iOS becomes much more likely to cancel the pan during mid-scrub refreshes.

**Final choice**:
- Keep the scrubber overlay **behind** the button for iOS stability
- Dim the button using `UNDO_SCRUB_BUTTON_DIM_OPACITY` so it still looks visually “de-emphasized” while scrubbing

