# 1-9 Atomic solver approaches and flows

[Back to task list](../tasks.md)

## Description
Document all "approaches" produced by the atomic flip solver and the decision flows that generate and rank them, based on `src/solitaire/klondike_solver_atomic.js`. An "approach" is the minimal-step path from an atomic snapshot (immediately after any tableau flip) to the next flip. This doc explains phases, move types, ranking strategies, backjumping, and normalization, with code references.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-29 10:00:00 | Status Change | Proposed | InProgress | Started documenting solver approaches and flows. | ai-agent |
| 2025-10-29 10:20:00 | Status Change | InProgress | Review | First complete draft with code references. | ai-agent |

## Requirements
- Define what an "approach" is and when approaches are collected.
- Describe move kinds and the generation phases (trivial-first, then general BFS).
- Explain ranking strategies: leastSteps, mostCovered, blended; include tie-breakers.
- Document backjumping across atomic layers and blocked/changed column logic.
- Show normalization rules that run between moves during search.
- Provide inline code references back to `klondike_solver_atomic.js` for each concept.

## Implementation Plan
- Extract concepts directly from the solver source; avoid duplicating logic.
- Organize the doc by discovery flow: normalization → BFS phases → ranking → atomic layering → backjumping.
- Add code references for maintainers to validate alignment quickly.

## Verification
- Cross-check each section’s description with the referenced code ranges.
- Spot-run the solver script to ensure terminology (“approach”, move kinds) matches console output and options.

## Files Modified
- `docs/delivery/1/1-9.md` (this document)
- `docs/delivery/1/tasks.md` (index entry added/updated)

---

## Key concepts and flows

### Atomic snapshot and normalization
Atomic snapshots are now taken only after exhausting all trivial (completely safe) foundation moves, even if those moves cause tableau flips. Flips caused by such trivial `t2f` moves do not create atomic boundaries; they are absorbed into normalization to reduce unique atomic states.

```154:192:src/solitaire/klondike_solver_atomic.js
function normalizeSafeToFoundationNoFlip(state, allowTableauFlip = false) {
    let changed = true
    while (changed) {
        changed = false
        // stock -> foundation
        // ... more code ...
        // tableau top -> foundation (optional flip depending on allowTableauFlip)
        // ... more code ...
    }
}
```

Normalization is invoked before BFS and after applying moves during search, with `allowTableauFlip = true` in atomic contexts.

### Approach generation (BFS to next flip)
For a given atomic snapshot, the solver performs a bounded BFS to collect all minimal-step paths that reach the next flip. These minimal first-hit paths are the "approaches" for that snapshot.

```323:348:src/solitaire/klondike_solver_atomic.js
function findNextFlipCandidates(rootState, budget) {
    const { maxLocalNodes, deadline, maxApproachSteps, avoidEmptyUnlessKing, trivialFirst = true } = budget
    let nodes = 0
    const root = cloneState(rootState)
    normalizeSafeToFoundationNoFlip(root)
    const rootKey = zobristKey(root)
    const seen = new Set([rootKey])
    const q = [{ state: root, steps: 0, path: [] }]
    const candidates = []
    // ... more code ...
}
```

#### Trivial-first phases
The BFS is staged to prefer inexpensive flips:
- Phase 1: foundation-only moves (`t2f`, `stock2f`)
- Phase 2: allow stock/tableau downs but no tableau shuffles (`stock2t`, `f2t`, plus foundation moves)

```389:396:src/solitaire/klondike_solver_atomic.js
if (trivialFirst) {
    // Phase 1: foundation-only (t2f, stock2f)
    const trivial1 = runBfsWithFilter((mv) => mv.kind === 't2f' || mv.kind === 'stock2f')
    if (trivial1.length) return { candidates: trivial1, nodesUsed: nodes }
    // Phase 2: allow stock/foundation downs but no tableau shuffles (stock2t, f2t, t2f, stock2f)
    const trivial2 = runBfsWithFilter((mv) => mv.kind === 't2f' || mv.kind === 'stock2f' || mv.kind === 'stock2t' || mv.kind === 'f2t')
    if (trivial2.length) return { candidates: trivial2, nodesUsed: nodes }
}
```

When these phases yield no flip, the general BFS explores all legal moves with configurable preferences (e.g., avoid emptying a column unless king-to-empty).

### Move kinds (used in approaches)
The solver emits approaches as sequences of these move kinds:
- `t2f`: tableau → foundation
- `t2t`: tableau stack → tableau column
- `stock2f`: stock → foundation
- `stock2t`: stock → tableau
- `f2t`: throttled foundation → tableau (only when no other moves exist)

Move generation and legality are implemented in `listMoves` and helpers.

```194:249:src/solitaire/klondike_solver_atomic.js
function listMoves(state) {
    const moves = []
    // tableau -> foundation
    // tableau -> tableau (any face-up stack)
    // stock -> foundation
    // stock -> tableau
    // throttled f2t only if no other moves
    return moves
}
```

### Candidate ranking (approach ordering)
After collecting all minimal-step approaches, the solver ranks them by a chosen strategy.

1) Least steps with domain tie-breakers:

```465:479:src/solitaire/klondike_solver_atomic.js
function rankCandidates(rootState, candidates) {
    // primary: fewer steps; ties: fewer remaining face-downs, more foundations, more empty columns
    return candidates.sort((a, b) => {
        // ... comparisons ...
    })
}
```

2) Most covered: prefer flipping a column that currently covers the most face-down cards (then fewer steps):

```504:516:src/solitaire/klondike_solver_atomic.js
function rankCandidatesByMostCovered(rootState, candidates) {
    // ... prefer larger count of covered cards before flip, then steps
}
```

3) Blended (default): most covered → fewest steps → fewer stock uses → fewer `f2t` uses → fewer columns touched by the path.

```530:549:src/solitaire/klondike_solver_atomic.js
function rankCandidatesBlended(rootState, candidates) {
    // Blended ranking: prioritize most covered, then fewer steps, then fewer stock/f2t uses, then fewer columns touched
}
```

The ranking strategy is selected via `options.rankingStrategy` (`'blended' | 'mostCovered' | 'leastSteps'`).

### Atomic layering, backtracking, and backjumping
The solver advances by applying the top-ranked approach, reaching the next atomic snapshot. If stuck or a duplicate atomic state is detected at the same-or-deeper flips depth, it backtracks. When backtracking through exhausted candidate lists, it can backjump to the most recent ancestor that changed any currently blocked column.

```652:685:src/solitaire/klondike_solver_atomic.js
if (top.idx >= top.candidates.length) {
    // Backjump: jump to most recent ancestor that changed any currently blocked column
    if (!enableBackjump) {
        // simple pop/backtrack
    }
    // compute currentBlocked and intersect with ancestor.changedCols
    // pop frames up to jump target and restore snapshot
    continue
}
```

Blocked/changed columns are tracked explicitly:

```584:607:src/solitaire/klondike_solver_atomic.js
function blockedColumnsOf(s) { /* ... */ }
function changedColumnsFromPath(path) { /* ... */ }
function sigOfChangedCols(set) { /* ... */ }
```

### Greedy finish
When all tableau cards are face-up, the solver greedily auto-completes to foundations and stops.

```302:321:src/solitaire/klondike_solver_atomic.js
function tryGreedyFinishIfReady(state) {
    if (!isAutoCompleteReady(state)) return false
    // ... move tableau and stock to foundations while possible ...
    return isWin(greedy)
}
```

---

## Glossary
- **Atomic snapshot**: State immediately after any tableau flip.
- **Approach**: Minimal-step path from an atomic snapshot to the next flip.
- **Trivial-first**: Prioritize flips reachable via foundation-only (and then non-shuffle) moves before exploring full BFS.
- **Blended ranking**: Default ranking that balances flip impact and path cost/side-effects.

## Notes for maintainers
- Keep normalization cheap and deterministic; it shapes the search frontier.
- If adding move kinds or tie-breakers, update all three ranking strategies coherently.
- Backjumping is optional but avoids thrashing when many columns are blocked; confirm behavior with `enableBackjump` toggles.


