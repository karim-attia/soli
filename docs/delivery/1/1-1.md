# [1-1] Stand up Klondike engine and reducer

[Back to task list](../tasks.md)

## Description
Model the Solitaire domain (cards, piles, deals, moves) and expose a reducer + helpers that enforce Klondike draw-one rules while tracking undo snapshots for downstream UI components.

## Status History
| Timestamp | Event Type | From Status | To Status | Details | User |
| :-- | :-- | :-- | :-- | :-- | :-- |
| 2025-10-26 13:16:00 | Created | N/A | Proposed | Task file created and scoped. | ai_agent |
| 2025-10-26 13:18:30 | user_approves | Proposed | Agreed | User-approved Solitaire MVP scope. | user |
| 2025-10-26 13:27:00 | start_work | Agreed | InProgress | Began implementing engine/reducer module. | ai_agent |
| 2025-10-26 13:45:00 | submit_for_review | InProgress | Review | Reducer + engine ready for UI integration. | ai_agent |
| 2025-10-26 13:50:00 | approve | Review | Done | Task implementation approved by user. | user |

## Requirements
- Represent suits, ranks, and piles with strongly typed structures and exported constants (per policy #12).
- Deal a randomized Klondike layout (7 tableau columns, 4 foundations, stock, waste) with correct face-up/down state.
- Provide pure helper functions for draw, move, recycling stock, and pushing undo states.
- Expose a reducer/action set the UI can dispatch without duplicating rules elsewhere.

## Implementation Plan
1. Create a dedicated module (e.g., `src/solitaire/klondike.ts`) housing types, constants, and helper functions.
2. Implement deck creation + deterministic shuffling plus initial deal logic returning a `GameState` snapshot.
3. Model move validation helpers for tableau stacking and foundation placement.
4. Define reducer actions (new game, draw, select/move, undo) that update state immutably and push to an `history` stack limited by a constant.
5. Export convenience selectors (e.g., `getMovableCards`, `canDropOnPile`) for UI hints.

## Test Plan
- TypeScript compilation succeeds (`yarn tsc --noEmit`).
- Reducer unit exercised indirectly via UI manual testing (tableau + foundation replacements behave as expected when triggered through the interface).
- Verify undo stack restores prior state order by performing at least two moves then undoing sequentially during manual run.

## Verification
- Stepped through reducer actions (deal, draw, recycle, tableau/foundation moves, undo) alongside the UI event wiring to ensure illegal moves are blocked and tableau flips occur automatically.
- `yarn tsc --noEmit` confirms the module type-checks with the wider project.

## Files Modified
- `src/solitaire/klondike.ts`
